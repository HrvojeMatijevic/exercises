<!doctype html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
 <head>

  

	<script src="https://cdn.jsdelivr.net/npm/ol@v10.3.1/dist/ol.js"></script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.3.1/ol.css">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>  
	<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
	<script src=" https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js "></script>

      
	<style>
      	.map {
        	width: 100%;
        	height: 600px;
      	}
    	</style>
</head>


<body>

   
<div id="map" class="map"></div>

<align="left"><button style="color:red;font-size:30px;" id="deleting" class="code">Briši</button>
<align="left"><button style="color:green;font-size:30px;" id="adding" class="code">Dodaj</button>
<span><align="left">Korisnik:<span id="userdisplay" ></span>


<div id="info" style="display: none;"></div>
<p>   
<align="right">
    <label for="track">
      GPS
      <input id="track" type="checkbox"/>
    </label>
      H. točnost : <code id="accuracy"></code>&nbsp;&nbsp;
</p>

<align="left"><button id="addbyloc" class="code">Dodaj gps</button>
<align="left"><button id="savefeature" class="code">U datoteku</button>
<align="left"><button id="locate" class="code">Lociraj</button>


 <label>
  	<b>Podloga:</b>
  	<select class="podloga" name="podloga">
   	 <option value="none">Ništa</option>
    	 <option value="dgudof">DOF</option>
   	 <option value="osm">OSM</option>
  	</select>
</label>

<label>Vektor</label>
<input id="vector" type="checkbox"/>


<script type="text/javascript">

console.log ("app version 0.52")

var pointSource = new ol.source.Vector();
var unprocessedMessages = [];
var clientId = Math.floor(Math.random() * 100000);
gjsonFormat = new ol.format["GeoJSON"]();
const osm = new ol.layer.Tile({source: new ol.source.OSM()});


var user = prompt("Unesi ime"); 


//const socket = io.connect('http://10.0.239.86:2500/', {'reconnection': true});
//const socket = io.connect('http://192.168.1.116:2500/', {'reconnection': true});
const socket = io.connect('https://dev.geoweb.hr/', {'reconnection': true});



// *********************************** EXTENDED  *******************************



class Coordinator {
	constructor () {
      		this.receivedMessages = {};
		this.liveMembers = new Set ();
		this.maxOwnMember = 0;
		this.maxOwnMessage = 0;
		this.targetSource = null;
	}


getNewMsgId () {
	this.maxOwnMessage++
	var newMessageId=clientId +"_"+ this.maxOwnMessage
	return newMessageId
}


getMemberById (id) {
	var member = this.content.get (id.join("::"))
	return member
}

addLocalMember (feature) {
	this.maxOwnMember++
	var newFid=clientId +"::"+ this.maxOwnMember
	this.liveMembers.add (newFid)
	feature.setId(newFid)
	
	var coords = feature.getGeometry().getCoordinates();
	var newMessage={ type:'addPoint', user: user, fid:newFid, coords:coords}

	return  newMessage
}


addRemoteMember (featData) {
	this.liveMembers.add (featData.fid)
	var newPtGeom = new ol.geom.Point(featData.coords)
	var ptFeat= new ol.Feature({geometry: newPtGeom})
	ptFeat.setId(featData.fid)
	ptFeat.set("attValue", featData.attValue)
	ptFeat.set("user", featData.user)

	if (Object.hasOwn(featData, "hzAcc")) ptFeat.set("hzAcc", featData.hzAcc)
	if (Object.hasOwn(featData, "altitude")) ptFeat.set("altitude", featData.altitude)

	this.targetSource.addFeature(ptFeat)
	return  ptFeat
}

canDeleteMember (id) {
	return this.liveMembers.has(id)
};

deleteMemberLocal (id) {
	this.liveMembers.delete (id)
	var delMessage={ type:'delPoint', user:user,  fid:id}
	return  delMessage
};


deleteMemberRemote (id) {
	this.liveMembers.delete (id)
	var delTarget=this.targetSource.getFeatureById(id)
	this.targetSource.removeFeature(delTarget)
};



} // Coordinator CLASS END

var mechanism= new Coordinator ()
mechanism.targetSource=pointSource




function postaddProcessor_full (feature, inText) {
	
	var msgNew=mechanism.addLocalMember (feature)
	msgNew.attValue=inText
	var msgId=mechanism.getNewMsgId ()
	var msgDel={}
	console.log (msgNew)
	socket.emit('standard_msg_full',  {id:msgId, new:msgNew, del:msgDel} );	
	mechanism.receivedMessages[msgId]="a"  // Need to accout for local messages too, otherwise the server will return my messages back to me when resyncing		
}


function postaddProcessorGPS_full (feature, inText, hzAcc, altitude ) {
	
	var msgNew=mechanism.addLocalMember (feature)
	msgNew.attValue=inText
	msgNew.hzAcc=hzAcc
	msgNew.altitude=altitude
	var msgId=mechanism.getNewMsgId ()
	var msgDel={}
	console.log (msgNew)
	socket.emit('standard_msg_full',  {id:msgId, new:msgNew, del:msgDel} );	
	mechanism.receivedMessages[msgId]="a"  // Need to accout for local messages too, otherwise the server will return my messages back to me when resyncing		
}



function postDelProcessor_full (fid) {
	
	var msgDel=mechanism.deleteMemberLocal (fid)
	var msgId=mechanism.getNewMsgId ()
	var msgNew={}
	console.log (msgDel)
	socket.emit('standard_msg_full',  {id:msgId, new:msgNew, del:msgDel} );	
	mechanism.receivedMessages[msgId]="a"  // Need to accout for local messages too, otherwise the server will return my messages back to me when resyncing		
}



function integrateMessagesFromBuffer(){
     var didAnything=false;
     var lastTurnDidAnything=true;
     
  // Repeat processing until we reach a turn where nothing happened or array empty  
  while (unprocessedMessages.length>0 && lastTurnDidAnything) {
     lastTurnDidAnything=false;
     var ctr=0; // Custom counter for array index
     
     // Process messeages and delete those that got integrated sequentially forward from the start of array (in order of arrival)
     while (unprocessedMessages.length>0 && ctr<unprocessedMessages.length) {
	var iCanDelete;
	var alreadyDeleted=false;
	
	// 1. Is there something to delete, and can we?
	if (unprocessedMessages [ctr].del.fid !== undefined) {
		console.log ("CHECKING DELETE")
		iCanDelete = mechanism.canDeleteMember  (unprocessedMessages [ctr].del.fid);
		console.log ("REULT " + iCanDelete)
		// Perhaps its already deleted. Let's check.
		if (iCanDelete) {
			//const itemPos=crdtDoc.findItem( unprocessedMessages [ctr].del.id, thisClientsLastInsertPos)
  			//const item = crdtDoc.content [itemPos]
  			//if (item.isDeleted) alreadyDeleted=true
		}
	} else {iCanDelete=true}

	

	// If the message is alreadyDeleted then its already integrated and needn't be processed
	// and can be deleted from inbuffer
	if (alreadyDeleted) {
		unprocessedMessages.splice (ctr,1);
		ctr--;
		console.log ("!!!redundant!!!")
	}

	// if not redundant then we process it
	if (iCanDelete) {
		didAnything=true;
		lastTurnDidAnything=true;

		if (unprocessedMessages [ctr].del.fid !== undefined) {
			mechanism.deleteMemberRemote (unprocessedMessages [ctr].del.fid)
		} 

		if (unprocessedMessages [ctr].new.fid !== undefined) {
			mechanism.addRemoteMember (unprocessedMessages [ctr].new)	
		} 

		// Finnaly, delete the message from buffer
		unprocessedMessages.splice (ctr,1);
		ctr--;	
	}
      
	ctr++;

    } // Inner while loop
  } // Outer while


  return didAnything;
};



socket.on('connected', function (data) {
	socket.emit('request_missing_messages',  mechanism.receivedMessages );
});


socket.on('connected', function (data) {
	document.getElementById("userdisplay").textContent=user;
	document.getElementById("userdisplay").style.color='green';
	document.getElementById("userdisplay").style.fontWeight='bold';

});


socket.on('disconnect', function (data) {
	document.getElementById("userdisplay").textContent=user;
	document.getElementById("userdisplay").style.color='red';
	document.getElementById("userdisplay").style.fontWeight='bold';
});


socket.on('deliver_resource', function (data) {
	var counter=0;
	Object.keys(data).forEach(key => { unprocessedMessages.push(data[key]); mechanism.receivedMessages[key]="a"; counter++ } );
	alert (" New messages " + counter)
	var didAnything=integrateMessagesFromBuffer();
});


socket.on('standard_msg_full', function (data) {
	processMessage_full(data);
});

function processMessage_full (msg) {
	unprocessedMessages.push(msg);
	mechanism.receivedMessages[msg.id]="a"
	var didAnything=integrateMessagesFromBuffer();
}


document.getElementById('savefeature').onclick = function() {
	var geoJsonFeature = gjsonFormat.writeFeatures(pointSource.getFeatures());
	var blob = new Blob([geoJsonFeature], {type: "text/plain;charset=utf-8"});
    	window.saveAs(blob, "tocke.geojson");
};

var dragAndDropInteraction = new ol.interaction.DragAndDrop({
       	 formatConstructors: [
       	   ol.format.GPX,
       	   ol.format.GeoJSON,
       	   ol.format.IGC,
       	   ol.format.KML,
       	   ol.format.TopoJSON
       	 ]
	}); 

dragAndDropInteraction.on('addfeatures', function(event) {
        
	pointSource.addFeatures(event.features);
	var feats=pointSource.getFeatures()
	for (var workingFeature of feats) {	
		postaddProcessor_full (workingFeature, workingFeature.get ("attValue"))		
	}
	map.getView().fit(pointSource.getExtent())

 });




// *********************************** END OF EXTENDED *******************************





proj4.defs('EPSG:3765','+proj=tmerc +lat_0=0 +lon_0=16.5 +k=0.9999 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
ol.proj.proj4.register(proj4);
var htrs96 = ol.proj.get('EPSG:3765');

const zgradeStyle = new ol.style.Style({
  stroke: new ol.style.Stroke({
    color: 'black',
    width: 2,
  }),
});


var zgradeIzvor = new ol.source.Vector({
        format: new ol.format.GeoJSON(),
        url: 'https://hrvojematijevic.github.io/exercises/resources/makarska_zgrade.geojson'
});


var zgradeLayer = new ol.layer.Vector({
    source: zgradeIzvor,
    style: zgradeStyle
});

el('vector').addEventListener('change', function () {
  zgradeLayer.setVisible(this.checked);
});


const DOF = new ol.layer.Tile({
            title: 'DOF 2011',
            type: 'base',
            visible: true,
            source: new ol.source.TileWMS({
            url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_lidar_2022_2023/wms',
	    //url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_2011/wms',
            params: {'LAYERS': 'OI.OrthoimageCoverage', 'TILED': true} 
	    //params: {'LAYERS': 'OrthoImagery', 'TILED': true}                  
                    })
 });   


let pointWithLabel = function (feature) {
  return new ol.style.Style({
	
	image: new ol.style.Circle({
      		radius: 3,
      		fill: new ol.style.Fill({color: 'yellow'}),
      		stroke: new ol.style.Stroke({color: 'red', width: 1})
       	}),
	
	text: new ol.style.Text({
		text: feature.get("attValue"), 
		font: '18px sans-serif', 
		fill: new ol.style.Fill({color: 'yellow'}), 
		stroke: new ol.style.Stroke({color: 'black', width: 2}),
		offsetY: -10   
	})
  });
}



var pointLayer = new ol.layer.Vector({
       source: pointSource,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: true,
        title: 'točke',
	style: pointWithLabel
});

var view = new ol.View({
	  projection: htrs96,
          minResolution: 0.05,
            center: [625000, 5020000],
          zoom: 12
})

var map = new ol.Map({
        target: 'map',
        view: view
});

map.addLayer(DOF);
map.addLayer(osm);	
map.addLayer(pointLayer);
map.addLayer(zgradeLayer);
DOF.setVisible (true); 
osm.setVisible (false);
zgradeLayer.setVisible (false);
map.addInteraction(dragAndDropInteraction);
	

const selectElement = document.querySelector('.podloga');
		selectElement.addEventListener('change', (event) => {
		if (event.target.value=='dgudof') {DOF.setVisible (true); osm.setVisible (false)}     
		if (event.target.value=='osm') {DOF.setVisible (false); osm.setVisible (true)} 
		if (event.target.value=='none') {DOF.setVisible (false); osm.setVisible (false)}       
}); 


drawPoint = new ol.interaction.Draw({
      source: pointSource,
      type: "Point",
    });
map.addInteraction(drawPoint);
drawPoint.setActive (true);

drawPoint.on('drawend',function(evt){
	console.log (evt.feature.values_.geometry.flatCoordinates)
	var coords=evt.feature.values_.geometry.flatCoordinates
	let inText = prompt("Unesi vrijednost atributa");
	if (inText == null || inText == "") {
  		evt.feature.set("removeMe",true)
	} else {
  		
		evt.feature.set("attValue",inText)
		evt.feature.set("user",user)
		//postaddProcessor (coords, inText)
		postaddProcessor_full (evt.feature, inText)
	} 
	
});



// Removes the points with attribute not filled in
pointSource.on ('addfeature',function(evt){	
	if (evt.feature.get("removeMe")) {
      		pointSource.removeFeature(evt.feature)
    	}
})


snap = new ol.interaction.Snap({source: pointSource});
map.addInteraction(snap);

var selectPoint = new ol.interaction.Select();
map.addInteraction(selectPoint);
drawPoint.setActive (false);


selectPoint.on('select',function(evt){	
	var targetFeat=selectPoint.getFeatures().getArray()[0] 
	var targetFid=targetFeat.getId()
	var doDelete=confirm ("Obrisati " + targetFeat.get("attValue"))
	if (doDelete) {
		postDelProcessor_full (targetFid)
		pointSource.removeFeature(targetFeat)
	}
})


document.getElementById('deleting').onclick = function() {	
	drawPoint.setActive(false);
	selectPoint.setActive(true);
};

document.getElementById('adding').onclick = function() {	
	drawPoint.setActive(true);
	selectPoint.setActive(false);
};




socket.on('standard_msg', function (data) {
	processMessage(data);
});


function processMessage (msg) {
	var newPtGeom = new ol.geom.Point(msg.new.coords);
	var ptFeat= new ol.Feature({geometry: newPtGeom});
	ptFeat.set ("attValue", msg.new.attValue)
	pointSource.addFeature(ptFeat);
}


function postaddProcessor (coords, inText) {

	msg={type:'addPoint', coords:coords, attValue:inText}
	socket.emit('standard_msg',  {id:1, new:msg} );			
}




// *************************** GEOLOCATION *******************************


const geolocation = new ol.Geolocation({
  // enableHighAccuracy must be set to true to have the heading value.
  trackingOptions: {
    enableHighAccuracy: true,
  },
  projection: view.getProjection(),
});

function el(id) {
  return document.getElementById(id);
}

el('track').addEventListener('change', function () {
  geolocation.setTracking(this.checked);
});

// update the HTML page when the position changes.
geolocation.on('change', function () {
  el('accuracy').innerText = geolocation.getAccuracy().toFixed(2) + ' [m]';
});

geolocation.on('error', function (error) {
  alert (error.message)
});


const accuracyFeature = new ol.Feature();
geolocation.on('change:accuracyGeometry', function () {
  accuracyFeature.setGeometry(geolocation.getAccuracyGeometry());
});

const positionFeature = new ol.Feature();
positionFeature.setStyle(
  new ol.style.Style({
    image: new ol.style.Circle({
      radius: 6,
      fill: new ol.style.Fill({
        color: '#3399CC',
      }),
      stroke: new ol.style.Stroke({
        color: '#fff',
        width: 2,
      }),
    }),
  }),
);


geolocation.on('change:position', function () {
  const coordinates = geolocation.getPosition();
  positionFeature.setGeometry(coordinates ? new ol.geom.Point(coordinates) : null);
});


new ol.layer.Vector({
  map: map,
  source: new ol.source.Vector({
    features: [accuracyFeature, positionFeature],
  }),
});



document.getElementById('locate').onclick = function() {
	if (geolocation.getTracking()) {	
		var myLocation = geolocation.getPosition()
		view.setCenter(myLocation)
		view.setZoom(20)
	} else alert ("Lokacija nije uključena")
};


document.getElementById('addbyloc').onclick = function() {
	if (geolocation.getTracking()) {	
		
		let inText = prompt("Unesi vrijednost atributa");

		if (inText == null || inText == "") {
  			null
		} else {
			
			var coords=geolocation.getPosition()
			var hzAcc=-1
			var altitude=-1
 			var hzAcc= geolocation.getAccuracy().toFixed(2) 
 			var altitude = geolocation.getAltitude().toFixed(2)  

			var newPtGeom = new ol.geom.Point(coords);
			var ptFeat= new ol.Feature({geometry: newPtGeom})
			ptFeat.set ("attValue", inText)
			if (hzAcc!==undefined) ptFeat.set ("hzAcc", hzAcc) 
			else hzAcc=-1
			if (altitude!==undefined) ptFeat.set ("altitude", altitude)
			else altitude=-100
			ptFeat.set ("user", user)
			pointSource.addFeature(ptFeat)
			//postaddProcessor (coords, inText)
			postaddProcessorGPS_full (ptFeat, inText, hzAcc, altitude)
		}

	} else alert ("Lokacija nije uključena")
};





    </script>
  </body>
</html>











		






							
							  









