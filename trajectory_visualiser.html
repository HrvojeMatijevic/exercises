<!DOCTYPE html>
<html lang="en">
<meta name="viewport" content="width=device-width, initial-scale=1">
<head>
<meta charset="utf-8" />
<title>B-spline Trajectory Predictor (click + GPS)</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.1.0/dist/ol.css" />
<style>
  html, body { height:100%; margin:0; font-family:system-ui,Segoe UI,Roboto,Arial; }
  #map { height: calc(100% - 150px); width:100%; }
  #controls {
    height: auto;
    padding: 12px;
    gap: 12px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    background:#f4f4f4;
    border-bottom:1px solid #ddd;
  }
  .btn {
    padding:10px 14px;
    border-radius:8px;
    border:1px solid #ccc;
    background:white;
    cursor:pointer;
    font-size:16px;
    min-height:44px;
    min-width:50px;
  }
  label {
    font-size:16px;
    display:flex;
    align-items:center;
    gap:4px;
  }
  input, select {
    font-size:16px;
    padding:4px 6px;
    min-width:50px;
  }
</style>
</head>
<body>
  <div id="controls">
    <label>Input:
      <select id="inputMode">
        <option value="click">Mouse click (desktop)</option>
        <option value="gps">GPS (phone)</option>
      </select>
    </label>

    <button id="clearBtn" class="btn">Clear</button>
    <button id="zoomBtn" class="btn">üìç Zoom to Me</button>

    <label>
      Phantom count:
      <input id="phantomCount" type="number" value="3" min="1" max="10"/>
    </label>
    <label>
      Extend factor:
      <input id="extendFactor" type="number" value="1.5" step="0.1" min="0.1"/>
    </label>

    <label>GPS mode:
      <select id="gpsMode">
        <option value="time">Time-based</option>
        <option value="distance">Distance-based</option>
      </select>
    </label>

    <label id="gpsTimeWrap">Interval (s):
      <input id="gpsTimeInterval" type="number" value="1" min="1"/>
    </label>
    <label id="gpsDistWrap" style="display:none">Distance (m):
      <input id="gpsDistanceThresh" type="number" value="10" min="1"/>
    </label>
  </div>

  <div id="map"></div>

  <script src="https://cdn.jsdelivr.net/npm/ol@v10.1.0/dist/ol.js"></script>
  <script>
  (function(){
    const { Map, View } = ol;
    const { Tile: TileLayer, Vector: VectorLayer } = ol.layer;
    const { OSM, Vector: VectorSource } = ol.source;
    const { LineString, Point } = ol.geom;
    const { Feature } = ol;
    const { Circle: CircleStyle, Fill, Stroke, Style } = ol.style;

    // Map
    const map = new Map({
      target: 'map',
      layers: [ new TileLayer({ source: new OSM() }) ],
      view: new View({ center: [0,0], zoom: 2 })
    });

    // Sources & layers
    const pointsSource = new VectorSource();
    const curveSource = new VectorSource();

    const pointsLayer = new VectorLayer({
      source: pointsSource,
      style: new Style({
        image: new CircleStyle({ radius:6, fill: new Fill({color:'#e63946'}), stroke: new Stroke({color:'#fff', width:2})})
      })
    });
    const curveLayer = new VectorLayer({
      source: curveSource,
      style: new Style({ stroke: new Stroke({ color: '#1d3557', width: 4 }) })
    });

    map.addLayer(curveLayer);
    map.addLayer(pointsLayer);

    // State
    let allPoints = [];
    const MAX_CONTROL = 5;
    const DEGREE = 3;

    // UI elements
    const inputMode = document.getElementById('inputMode');
    const clearBtn = document.getElementById('clearBtn');
    const zoomBtn = document.getElementById('zoomBtn');
    const phantomCountInput = document.getElementById('phantomCount');
    const extendFactorInput = document.getElementById('extendFactor');
    const gpsModeSelect = document.getElementById('gpsMode');
    const gpsTimeWrap = document.getElementById('gpsTimeWrap');
    const gpsDistWrap = document.getElementById('gpsDistWrap');

    // Geolocation
    let geolocation = null;
    let lastGpsTime = 0;
    let lastGpsCoord = null;

    function ensureGeolocation(){
      if(geolocation) return geolocation;
      geolocation = new ol.Geolocation({
        tracking: false,
        projection: map.getView().getProjection()
      });
      geolocation.on('change:position', () => {
        const pos = geolocation.getPosition();
        if(!pos) return;
        if(inputMode.value !== 'gps') return;

        const now = Date.now();
        const mode = gpsModeSelect.value;

        if(mode === 'time'){
          const interval = parseInt(document.getElementById('gpsTimeInterval').value,10)*1000;
          if(now - lastGpsTime >= interval){
            addPoint(pos);
            lastGpsTime = now;
            lastGpsCoord = pos;
          }
        } else if(mode === 'distance'){
          const minDist = parseFloat(document.getElementById('gpsDistanceThresh').value);
          if(!lastGpsCoord || ol.sphere.getDistance(
            ol.proj.toLonLat(lastGpsCoord),
            ol.proj.toLonLat(pos)
          ) >= minDist){
            addPoint(pos);
            lastGpsCoord = pos;
            lastGpsTime = now;
          }
        }
      });
      return geolocation;
    }

    // Map click handling
    map.on('singleclick', (evt) => {
      if(inputMode.value === 'click') addPoint(evt.coordinate);
    });

    // Clear
    clearBtn.addEventListener('click', () => {
      allPoints = [];
      pointsSource.clear();
      curveSource.clear();
    });

    // Zoom to current location
    zoomBtn.addEventListener('click', () => {
      if(!geolocation) return;
      const pos = geolocation.getPosition();
      if(pos){
        map.getView().animate({center: pos, zoom: 18});
      }
    });

    // Input mode
    inputMode.addEventListener('change', () => {
      if(inputMode.value === 'gps'){
        ensureGeolocation().setTracking(true);
      } else {
        if(geolocation) geolocation.setTracking(false);
      }
    });

    // GPS mode toggle UI
    gpsModeSelect.addEventListener('change', () => {
      gpsTimeWrap.style.display = gpsModeSelect.value === 'time' ? '' : 'none';
      gpsDistWrap.style.display = gpsModeSelect.value === 'distance' ? '' : 'none';
    });

    // Add point
    function addPoint(coord){
      allPoints.push(coord.slice ? coord.slice() : [coord[0], coord[1]]);
      redrawAll();
    }

    // Redraw points & curve
    function redrawAll(){
      pointsSource.clear();
      curveSource.clear();
      if(allPoints.length === 0) return;

      const controls = allPoints.slice(-MAX_CONTROL);
      for(const p of controls){
        pointsSource.addFeature(new Feature(new Point(p)));
      }

      if(controls.length < 2) return;

      const phantomCount = Math.max(1, parseInt(phantomCountInput.value||'3',10));
      const extendFactor = parseFloat(extendFactorInput.value)||1.5;
      const sampled = fitAndExtendBSpline(controls, DEGREE, phantomCount, extendFactor, 120);

      if(sampled && sampled.length>1){
        curveSource.addFeature(new Feature(new LineString(sampled)));
      }
    }

    // ---------- B-spline helpers ----------
    function makeClampedKnots(m, degree){
      const klen = m + degree + 2;
      const knots = new Array(klen);
      const inner = klen - 2*(degree+1);
      for(let i=0;i<=degree;i++) knots[i]=0;
      for(let j=1;j<=inner;j++) knots[degree+j]=j/(inner+1);
      for(let i=klen-degree-1;i<klen;i++) knots[i]=1;
      return knots;
    }

    function basisCoxDeBoor(i,k,u,knots){
      if(k===0) return (knots[i]<=u && u<knots[i+1])?1:0;
      let term1=0, term2=0;
      const denom1=knots[i+k]-knots[i];
      const denom2=knots[i+k+1]-knots[i+1];
      if(denom1) term1=((u-knots[i])/denom1)*basisCoxDeBoor(i,k-1,u,knots);
      if(denom2) term2=((knots[i+k+1]-u)/denom2)*basisCoxDeBoor(i+1,k-1,u,knots);
      return term1+term2;
    }

    function evaluateBSplineAt(ctrl, deg, knots, u){
      const m=ctrl.length-1; if(u>=1) return ctrl[m].slice();
      const pt=[0,0];
      for(let i=0;i<=m;i++){
        const b=basisCoxDeBoor(i, deg, u, knots);
        pt[0]+=b*ctrl[i][0]; pt[1]+=b*ctrl[i][1];
      }
      return pt;
    }

    function fitAndExtendBSpline(controlPts, degree=3, phantomCount=3, extendFactor=1.5, sampleSteps=100){
      const ctrl = controlPts.slice();
      if(ctrl.length<2) return ctrl.slice();
      if(ctrl.length<5) return ctrl.slice(); // fewer points ‚Üí no extension

      const last=ctrl[ctrl.length-1], prev=ctrl[ctrl.length-2];
      let tx=last[0]-prev[0], ty=last[1]-prev[1], tlen=Math.hypot(tx,ty);
      if(tlen===0){tx=1; ty=0; tlen=1;}
      const dir=[tx/tlen, ty/tlen];

      let avgSeg=0;
      for(let i=1;i<ctrl.length;i++){
        avgSeg+=Math.hypot(ctrl[i][0]-ctrl[i-1][0], ctrl[i][1]-ctrl[i-1][1]);
      }
      avgSeg/=Math.max(1,ctrl.length-1);

      for(let k=1;k<=phantomCount;k++){
        const step=avgSeg*k*extendFactor;
        ctrl.push([last[0]+dir[0]*step, last[1]+dir[1]*step]);
      }

      const m=ctrl.length-1, deg=Math.min(degree,m);
      const knots=makeClampedKnots(m,deg);
      const coords=[];
      for(let s=0;s<=sampleSteps;s++){
        const u=Math.min(s/sampleSteps,1);
        coords.push(evaluateBSplineAt(ctrl,deg,knots,u));
      }
      return coords;
    }

    inputMode.dispatchEvent(new Event('change'));
    window._bspline_predictor={addPoint, redrawAll, allPoints};

  })();
  </script>
</body>
</html>
