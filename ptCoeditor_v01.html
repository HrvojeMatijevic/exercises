<!doctype html>
<html lang="en">
 <head>

  

	<script src="https://cdn.jsdelivr.net/npm/ol@v10.3.1/dist/ol.js"></script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.3.1/ol.css">

	<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>  
	<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
	<script src=" https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js "></script>

      
	<style>
      	.map {
        	width: 100%;
        	height: 600px;
      	}
    	</style>
</head>


<body>

   
<div id="map" class="map"></div>
    

<script type="text/javascript">

var pointSource = new ol.source.Vector();
var unprocessedMessages = [];
var clientId = Math.floor(Math.random() * 100000);



// *********************************** COORDINATOR *******************************
class Coordinator {
	constructor () {
      		this.receivedMessages = {};
		this.liveMembers = new Set ();
		this.maxOwnMember = 0;
		this.maxOwnMessage = 0;
		this.targetSource = null;
	}


getNewMsgId () {
	this.maxOwnMessage++
	var newMessageId=clientId +"_"+ this.maxOwnMessage
	return newMessageId
}


getMemberById (id) {
	var member = this.content.get (id.join("::"))
	return member
}

addLocalMember (feature) {
	this.maxOwnMember++
	var newFid=clientId +"::"+ this.maxOwnMember
	this.liveMembers.add (newFid)
	feature.setId(newFid)
	
	var coords = feature.getGeometry().getCoordinates();
	var newMessage={ type:'addPoint', fid:newFid, coords:coords}

	return  newMessage
}


addRemoteMember (featData) {
	this.liveMembers.add (featData.fid)
	var newPtGeom = new ol.geom.Point(featData.coords);
	var ptFeat= new ol.Feature({geometry: newPtGeom});
	ptFeat.setId(featData.fid)
	this.targetSource.addFeature(ptFeat);
	return  ptFeat
}

canDeleteMember (id) {
	return this.liveMembers.has(id)
};

deleteMember (id) {
	var feat=this.targetSource.getFeatureById(id)
	this.targetSource.removeFeature(feat)
	this.liveMembers.delete (id)
};


} // Coordinator CLASS END

var mechanism= new Coordinator ()
mechanism.targetSource=pointSource

// *********************************** END OF COORDINATOR *******************************








//const socket = io.connect('http://10.0.239.86:2500/', {'reconnection': false});
//const socket = io.connect('http://192.168.1.116:2500/', {});
//const socket = io.connect('https://dev.geoweb.hr/', {'reconnection': false});


const socket = io.connect('https://three-general-sand.glitch.me:3000/', {});



proj4.defs('EPSG:3765','+proj=tmerc +lat_0=0 +lon_0=16.5 +k=0.9999 +x_0=500000 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
ol.proj.proj4.register(proj4);
var htrs96 = ol.proj.get('EPSG:3765');


const DOF = new ol.layer.Tile({
            title: 'DOF 2011',
            type: 'base',
            visible: true,
            source: new ol.source.TileWMS({
            //url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_2019_2020/wms',
	    url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_2011/wms',
            //params: {'LAYERS': 'OI.OrthoimageCoverage', 'TILED': true} 
	    params: {'LAYERS': 'OrthoImagery', 'TILED': true}                  
                    })
 });   

const osm = new ol.layer.Tile({source: new ol.source.OSM()});



const stilPt1 = [
     new ol.style.Style({
    		image: new ol.style.Circle({
      		radius: 4,
      		fill: new ol.style.Fill({color: 'yellow'}),
      		stroke: new ol.style.Stroke({color: 'yellow', width: 2})
       		})
     })     
];

var pointLayer = new ol.layer.Vector({
       source: pointSource,
           minResolution: 0.01,
           maxResolution: 100000,
        visible: true,
        title: 'točke',
	style: stilPt1
});

var view = new ol.View({
	  projection: htrs96,
          minResolution: 0.05,
            center: [625000, 5020000],
          zoom: 12
})

var map = new ol.Map({
        target: 'map',
        view: view
});

map.addLayer(DOF);	
map.addLayer(pointLayer);
DOF.setVisible (true); 
	



drawPoint = new ol.interaction.Draw({
      source: pointSource,
      type: "Point",
    });
map.addInteraction(drawPoint);
drawPoint.setActive (true);

drawPoint.on('drawend',function(evt){
	console.log (evt.feature.values_.geometry.flatCoordinates)
	var coords=evt.feature.values_.geometry.flatCoordinates
	//postaddProcessor (coords)
	postaddProcessor_full (evt.feature)
});


modifyPoint = new ol.interaction.Modify({
      source: pointSource,
    });
map.addInteraction(modifyPoint);
modifyPoint.setActive (true);
snap = new ol.interaction.Snap({source: pointSource});
map.addInteraction(snap);


modifyPoint.on('modifystart',function(evt){
	console.log (evt)
})

modifyPoint.on('modifyend',function(evt){
	console.log ("NA KRAJU")
	console.log (evt)
})





socket.on('standard_msg', function (data) {
	//processMessage(data);
	processMessage_full(data);
});

socket.on('connected', function (data) {
	socket.emit('request_missing_messages',  mechanism.receivedMessages );
});


socket.on('deliver_resource', function (data) {
	var counter=0;
	Object.keys(data).forEach(key => { unprocessedMessages.push(data[key]); mechanism.receivedMessages[key]="a"; counter++ } );
	alert (" New messages " + counter)
	var didAnything=integrateMessagesFromBuffer();
});





function postaddProcessor (coords) {
	msg={type:'addPoint', coords:coords}
	socket.emit('standard_msg',  msg );			
}

function processMessage (msg) {
	var newPtGeom = new ol.geom.Point(msg.coords);
	var ptFeat= new ol.Feature({geometry: newPtGeom});
	pointSource.addFeature(ptFeat);
}




function processMessage_full (msg) {
	unprocessedMessages.push(msg);
	mechanism.receivedMessages[msg.id]="a"
	var didAnything=integrateMessagesFromBuffer();
}

function postaddProcessor_full (feature) {
	
	var msgNew=mechanism.addLocalMember (feature)
	var msgId=mechanism.getNewMsgId ()
	var delMsg={}
	console.log (msgNew)
	socket.emit('standard_msg',  {id:msgId, new:msgNew, del:delMsg} );			
}


function integrateMessagesFromBuffer(){
     var didAnything=false;
     var lastTurnDidAnything=true;
     
  // Repeat processing until we reach a turn where nothing happened or array empty  
  while (unprocessedMessages.length>0 && lastTurnDidAnything) {
     lastTurnDidAnything=false;
     var ctr=0; // Custom counter for array index
     
     // Process messeages and delete those that got integrated sequentially forward from the start of array (in order of arrival)
     while (unprocessedMessages.length>0 && ctr<unprocessedMessages.length) {
	var iCanDelete;
	var alreadyDeleted=false;
	
	// 1. Is there something to delete, and can we?
	if (unprocessedMessages [ctr].del.fid !== undefined) {
		iCanDelete = mechanism.canDeleteMember  (unprocessedMessages [ctr].del.fid);
		// Perhaps its already deleted. Let's check.
		if (iCanDelete) {
			//const itemPos=crdtDoc.findItem( unprocessedMessages [ctr].del.id, thisClientsLastInsertPos)
  			//const item = crdtDoc.content [itemPos]
  			//if (item.isDeleted) alreadyDeleted=true
		}
	} else {iCanDelete=true}

	

	// If the message is alreadyDeleted then its already integrated and needn't be processed
	// and can be deleted from inbuffer
	if (alreadyDeleted) {
		unprocessedMessages.splice (ctr,1);
		ctr--;
		console.log ("!!!redundant!!!")
	}

	// if not redundant then we process it
	if (iCanDelete) {
		didAnything=true;
		lastTurnDidAnything=true;

		if (unprocessedMessages [ctr].del.fid !== undefined) {
			mechanism.deleteMember (unprocessedMessages [ctr].del)
		} 

		if (unprocessedMessages [ctr].new.fid !== undefined) {
			mechanism.addRemoteMember (unprocessedMessages [ctr].new)	
		} 

		// Finnaly, delete the message from buffer
		unprocessedMessages.splice (ctr,1);
		ctr--;	
	}
      
	ctr++;

    } // Inner while loop
  } // Outer while


  return didAnything;
};







    </script>
  </body>
</html>











		






							
							  









