<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Points + Zones Editor + 3D Tiles (EPSG:3765)</title>

<!-- OpenLayers -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.1.0/ol.css">

<!-- Cesium CSS (for basic styling; no viewer UI) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cesium@latest/Build/Cesium/Widgets/widgets.css">

<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  /* Main split container */
  #mainContainer {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: row;
  }

  /* Left: OpenLayers map */
  #map2d {
    flex: 1 1 50%;
    height: 100%;
    position: relative;
  }

  /* Right: Cesium */
  #map3d {
    flex: 1 1 50%;
    height: 100%;
    position: relative;
  }

  /* Cesium canvas will be inside map3d container */

  /* Controls over OL (left side) */
  #controls {
    position: absolute;
    top: 10px;
    left: 10px;
    background: rgba(255,255,255,0.96);
    padding: 10px;
    z-index: 1000;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.15);
    width: 270px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    font-size: 14px;
  }
  #controls h3 { margin: 6px 0 4px; font-size: 14px; }
  .row { margin-top: 6px; display:flex; gap:6px; flex-wrap:wrap; }
  button, input[type="text"] {
    font-size: 13px; padding: 6px 8px;
    border: 1px solid #ccc; border-radius: 6px;
    background: #fff; cursor: pointer;
  }
  button.active { background: #e8f7e8; border-color: #66bb66; }
  label { display:block; margin-top: 4px; }
  #coords {
    margin-top: 8px; padding: 6px; background:#fff;
    border:1px solid #ddd; border-radius:6px;
    font-variant-numeric: tabular-nums;
  }
  #hint {
    margin-top: 6px; padding: 5px 6px;
    background: #f8fbff; border: 1px dashed #aac;
    border-radius: 6px; color: #334;
  }
</style>
</head>
<body>

<div id="mainContainer">
  <!-- LEFT: OpenLayers 2D editor -->
  <div id="map2d">
    <div id="controls">
      <h3>Modes</h3>
      <div class="row">
        <button id="btnAddPts" class="active">Add Points</button>
        <button id="btnDelPts">Delete Points</button>
      </div>
      <div class="row">
        <button id="btnDrawPoly">Draw Zone</button>
        <button id="btnDelPoly">Delete Zone</button>
      </div>
      <div id="hint">Add Points ON: click map to add user points.</div>

      <h3>Layers</h3>
      <label><input type="checkbox" id="toggleWMS" checked> Orthophoto WMS</label>
      <label><input type="checkbox" id="toggleRefPolys" checked> Reference Polygons</label>
      <label><input type="checkbox" id="togglePred" checked> Predicted Points</label>
      <label><input type="checkbox" id="toggleUserPts" checked> User Points</label>
      <label><input type="checkbox" id="toggleZones" checked> Zones</label>
      <label><input type="checkbox" id="togglePtIds" checked> Show Point IDs</label>
      <label><input type="checkbox" id="toggleZoneIds" checked> Show Zone IDs</label>
      <label><input type="checkbox" id="togglePredConf" checked> Predicted Confidence</label>

      <h3>Data</h3>
      <div class="row">
        <button id="btnExport">Export GeoJSON</button>
      </div>
      <small>Import points/zones/predictions: drag & drop GeoJSON onto map.</small>

      <h3>Find Point by ID</h3>
      <div class="row">
        <input type="text" id="findId" placeholder="Point ID" style="width:90px;">
        <button id="btnFind">Find</button>
      </div>

      <div id="coords">
        X: <span id="coordX">-</span><br>
        Y: <span id="coordY">-</span>
      </div>
    </div>
  </div>

  <!-- RIGHT: Cesium (3D) -->
  <div id="map3d"></div>
</div>

<!-- OpenLayers -->
<script src="https://cdn.jsdelivr.net/npm/ol@v10.1.0/dist/ol.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>

<!-- CesiumJS + OL-Cesium -->
<script>
  // Tell Cesium where to find its assets
  window.CESIUM_BASE_URL = 'https://cdn.jsdelivr.net/npm/cesium@latest/Build/Cesium/';
</script>
<script src="https://cdn.jsdelivr.net/npm/cesium@latest/Build/Cesium/Cesium.js"></script>
<script src="https://cdn.jsdelivr.net/npm/ol-cesium@2.17.0/dist/olcesium.min.js"></script>

<script>
// Disable Cesium Ion (no token needed)
Cesium.Ion.defaultAccessToken = undefined;

/* =========================
   Projection EPSG:3765
========================= */
proj4.defs('EPSG:3765',
  '+proj=tmerc +lat_0=0 +lon_0=16.5 +k=0.9999 +x_0=500000 +y_0=0 +ellps=GRS80 +units=m +no_defs'
);
ol.proj.proj4.register(proj4);
const PROJ = 'EPSG:3765';

/* =========================
   URLs
========================= */
const WMS_URL = 'https://geoportal.dgu.hr/services/inspire/orthophoto_lidar_2022_2023/wms';
const WMS_LAYERS = 'OI.OrthoimageCoverage';
const REF_POLYS_URL = 'https://hrvojematijevic.github.io/exercises/resources/simplified_radial_1m.geojson';

// 3D tileset URL (intensity/greyscale)
const TILESET_URL = 'https://mak1.pages.dev/tileset.json'; // change if needed

/* =========================
   Sources
========================= */
const wmsLayer = new ol.layer.Tile({
  visible: true,
  source: new ol.source.TileWMS({
    url: WMS_URL,
    params: { LAYERS: WMS_LAYERS, TILED: true },
  }),
});

const refPolysSource = new ol.source.Vector({
  format: new ol.format.GeoJSON(),
  url: REF_POLYS_URL
});
const refPolysLayer = new ol.layer.Vector({
  source: refPolysSource,
  visible: true,
  style: new ol.style.Style({
    stroke: new ol.style.Stroke({ color: 'rgba(30,200,60,0.9)', width: 2 }),
    fill: new ol.style.Fill({ color: 'rgba(30,200,60,0.08)' })
  })
});

const userPtsSource = new ol.source.Vector();
const predPtsSource = new ol.source.Vector();
const zonesSource = new ol.source.Vector();

/* =========================
   ID counters (never reused)
========================= */
let nextPointId = 1;
let nextZoneId = 1;

function updateNextIdsFromSources() {
  const pids = userPtsSource.getFeatures()
    .map(f => Number(f.get('id')))
    .filter(n => Number.isFinite(n));
  if (pids.length) nextPointId = Math.max(...pids) + 1;

  const zids = zonesSource.getFeatures()
    .map(f => Number(f.get('id')))
    .filter(n => Number.isFinite(n));
  if (zids.length) nextZoneId = Math.max(...zids) + 1;
}

/* =========================
   Style helpers
========================= */
function hexToRgba(hex, a=1) {
  const h = hex.replace('#','').trim();
  const full = h.length === 3 ? h.split('').map(c=>c+c).join('') : h;
  const n = parseInt(full, 16);
  const r = (n>>16)&255, g=(n>>8)&255, b=n&255;
  return `rgba(${r},${g},${b},${a})`;
}

function pointSizeForResolution(res) {
  // strong shrink, small points overall
  if (res > 25) return 2;
  if (res > 12) return 3;
  if (res > 6)  return 4;
  if (res > 3)  return 5;
  return 6;
}

/* =========================
   User points layer
========================= */
const userPtsLayer = new ol.layer.Vector({
  source: userPtsSource,
  visible: true,
  style: (f, res) => new ol.style.Style({
    image: new ol.style.Circle({
      radius: pointSizeForResolution(res),
      fill: new ol.style.Fill({ color: '#000' }),
      stroke: new ol.style.Stroke({ color: '#fff', width: 1 })
    })
  })
});

/* =========================
   Predicted points layer
   - read-only
   - bigger + semi-transparent
========================= */
const predPtsLayer = new ol.layer.Vector({
  source: predPtsSource,
  visible: true,
  style: (f, res) => {
    const r = pointSizeForResolution(res) * 1.5;
    return new ol.style.Style({
      image: new ol.style.Circle({
        radius: r,
        fill: new ol.style.Fill({ color: hexToRgba('#ff0000', 0.6) }),
        stroke: new ol.style.Stroke({ color: '#111', width: 1 })
      })
    });
  }
});

/* =========================
   Predicted confidence labels
========================= */
const predConfLayer = new ol.layer.Vector({
  source: predPtsSource,
  visible: true,
  style: (feature, resolution) => {
    const c = feature.get('confidence');
    if (c === undefined || c === null) return null;
    const text = Number(c).toFixed(1);
    return new ol.style.Style({
      text: new ol.style.Text({
        text,
        font: '12px Calibri,sans-serif',
        fill: new ol.style.Fill({ color: '#000' }),
        stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
        offsetY: -16,
        textAlign: 'center'
      })
    });
  }
});

/* =========================
   Zones (editable polygons) layer
========================= */
const zonesLayer = new ol.layer.Vector({
  source: zonesSource,
  visible: true,
  style: new ol.style.Style({
    stroke: new ol.style.Stroke({ color: 'rgba(0,90,255,0.9)', width: 2 }),
    fill: new ol.style.Fill({ color: 'rgba(0,0,0,0.0)' })
  })
});

/* =========================
   ID label layers
========================= */
function fontForResolution(res) {
  if (res > 20) return '10px Calibri,sans-serif';
  if (res > 8)  return '11px Calibri,sans-serif';
  if (res > 3)  return '12px Calibri,sans-serif';
  return '13px Calibri,sans-serif';
}

const userPtIdLayer = new ol.layer.Vector({
  source: userPtsSource,
  visible: true,
  style: (feature, res) => {
    const id = feature.get('id');
    if (id == null) return null;
    return new ol.style.Style({
      text: new ol.style.Text({
        text: String(id),
        font: fontForResolution(res),
        fill: new ol.style.Fill({ color: '#000' }),
        stroke: new ol.style.Stroke({ color: '#fff', width: 3 }),
        offsetY: -12
      })
    });
  }
});

const zoneIdLayer = new ol.layer.Vector({
  source: zonesSource,
  visible: true,
  style: (feature, res) => {
    const id = feature.get('id');
    if (id == null) return null;
    const geom = feature.getGeometry();
    const p = geom.getInteriorPoint ? geom.getInteriorPoint() : null;
    const coord = p ? p.getCoordinates() : geom.getFirstCoordinate();

    return new ol.style.Style({
      geometry: new ol.geom.Point(coord),
      text: new ol.style.Text({
        text: String(id),
        font: fontForResolution(res),
        fill: new ol.style.Fill({ color: '#000' }),
        stroke: new ol.style.Stroke({ color: '#fff', width: 3 })
      })
    });
  }
});

/* =========================
   Shared view for 2D + 3D
========================= */
const sharedView = new ol.View({
  center: [500000, 0],
  zoom: 5,
  projection: PROJ
});

/* =========================
   Maps
   - map2d: visible editor
   - map3d: backing OL map for Cesium
========================= */
const map2d = new ol.Map({
  target: 'map2d',
  layers: [
    wmsLayer,
    refPolysLayer,
    predPtsLayer,
    predConfLayer,
    zonesLayer,
    userPtsLayer,
    userPtIdLayer,
    zoneIdLayer
  ],
  view: sharedView
});

const map3d = new ol.Map({
  target: 'map3d',
  layers: [wmsLayer], // no OL layers in 3D for now; Cesium tiles only
  view: sharedView
});

/* =========================
   Initial fit to reference polygons (affects both maps via shared view)
========================= */
refPolysSource.once('change', () => {
  if (refPolysSource.getState() === 'ready') {
    const ext = refPolysSource.getExtent();
    if (ext && !isNaN(ext[0])) {
      sharedView.fit(ext, { padding:[40,40,40,40], duration:300 });
    }
  }
});

/* =========================
   Mouse coords readout (from 2D map)
========================= */
map2d.on('pointermove', evt => {
  const c = evt.coordinate;
  document.getElementById('coordX').textContent = c[0].toFixed(1);
  document.getElementById('coordY').textContent = c[1].toFixed(1);
});

/* =========================
   Interactions (2D map only)
========================= */
const selectZones = new ol.interaction.Select({ layers: [zonesLayer] });
map2d.addInteraction(selectZones);

const modifyZones = new ol.interaction.Modify({ source: zonesSource });
map2d.addInteraction(modifyZones);

// draw polygons (added/removed depending on mode)
let drawZones = null;

/* =========================
   Modes
========================= */
let mode = 'addPoints'; // addPoints | deletePoints | drawZones | deleteZones

const btnAddPts = document.getElementById('btnAddPts');
const btnDelPts = document.getElementById('btnDelPts');
const btnDrawPoly = document.getElementById('btnDrawPoly');
const btnDelPoly = document.getElementById('btnDelPoly');
const hint = document.getElementById('hint');

function clearDrawInteraction() {
  if (drawZones) {
    map2d.removeInteraction(drawZones);
    drawZones = null;
  }
}

function setMode(m) {
  mode = m;

  // Zone interactions only active during zone modes
  const zoneMode = (m === 'drawZones' || m === 'deleteZones');
  selectZones.setActive(zoneMode);
  modifyZones.setActive(zoneMode);

  btnAddPts.classList.toggle('active', mode === 'addPoints');
  btnDelPts.classList.toggle('active', mode === 'deletePoints');
  btnDrawPoly.classList.toggle('active', mode === 'drawZones');
  btnDelPoly.classList.toggle('active', mode === 'deleteZones');

  clearDrawInteraction();

  if (mode === 'addPoints') {
    hint.textContent = 'Add Points ON: click map to add user points.';
    map2d.getTargetElement().style.cursor = 'crosshair';
    return;
  }

  if (mode === 'deletePoints') {
    hint.textContent = 'Delete Points ON: click a USER point to delete.';
    map2d.getTargetElement().style.cursor = 'not-allowed';
    return;
  }

  if (mode === 'drawZones') {
    hint.textContent = 'Draw Zone ON: click to draw polygon, double-click to finish.';
    map2d.getTargetElement().style.cursor = 'crosshair';
    drawZones = new ol.interaction.Draw({
      source: zonesSource,
      type: 'Polygon'
    });
    drawZones.on('drawend', (e) => {
      const f = e.feature;
      f.set('id', nextZoneId++);
      zonesSource.changed();
    });
    map2d.addInteraction(drawZones);
    return;
  }

  if (mode === 'deleteZones') {
    hint.textContent = 'Delete Zone ON: click a zone to delete (confirm).';
    map2d.getTargetElement().style.cursor = 'not-allowed';
    return;
  }
}

btnAddPts.onclick = () => setMode('addPoints');
btnDelPts.onclick = () => setMode('deletePoints');
btnDrawPoly.onclick = () => setMode('drawZones');
btnDelPoly.onclick = () => setMode('deleteZones');

setMode('addPoints');

/* =========================
   Click handling for add/delete (2D map)
========================= */
map2d.on('singleclick', (evt) => {
  if (mode === 'addPoints') {
    const f = new ol.Feature(new ol.geom.Point(evt.coordinate));
    f.set('id', nextPointId++);
    userPtsSource.addFeature(f);
    return;
  }

  if (mode === 'deletePoints') {
    const feats = map2d.getFeaturesAtPixel(evt.pixel, {
      layerFilter: l => l === userPtsLayer
    });
    if (feats && feats.length) {
      const f = feats[0];
      const id = f.get('id');
      if (confirm(`Delete USER point ID=${id}?`)) {
        userPtsSource.removeFeature(f);
      }
    }
    return;
  }

  if (mode === 'deleteZones') {
    const feats = map2d.getFeaturesAtPixel(evt.pixel, {
      layerFilter: l => l === zonesLayer
    });
    if (feats && feats.length) {
      const f = feats[0];
      const id = f.get('id');
      if (confirm(`Delete ZONE ID=${id}?`)) {
        zonesSource.removeFeature(f);
        selectZones.getFeatures().clear();
      }
    }
    return;
  }
});

/* =========================
   Layer toggles
========================= */
document.getElementById('toggleWMS').onchange = e => wmsLayer.setVisible(e.target.checked);
document.getElementById('toggleRefPolys').onchange = e => refPolysLayer.setVisible(e.target.checked);
document.getElementById('togglePred').onchange = e => predPtsLayer.setVisible(e.target.checked);
document.getElementById('toggleUserPts').onchange = e => userPtsLayer.setVisible(e.target.checked);
document.getElementById('toggleZones').onchange = e => zonesLayer.setVisible(e.target.checked);
document.getElementById('togglePtIds').onchange = e => userPtIdLayer.setVisible(e.target.checked);
document.getElementById('toggleZoneIds').onchange = e => zoneIdLayer.setVisible(e.target.checked);
document.getElementById('togglePredConf').onchange = e => predConfLayer.setVisible(e.target.checked);

/* =========================
   GeoJSON import (D&D)
   - Point with confidence -> predicted points
   - Point otherwise -> user point
   - Polygon -> zone
   Fit view to ALL imported user+zones+predicted.
========================= */
function fitToAllDataIfAny() {
  const hasUser = userPtsSource.getFeatures().length > 0;
  const hasPred = predPtsSource.getFeatures().length > 0;
  const hasZones = zonesSource.getFeatures().length > 0;
  if (!hasUser && !hasPred && !hasZones) return;

  let ext = null;
  if (hasUser) ext = userPtsSource.getExtent().slice();
  if (hasPred) {
    const e2 = predPtsSource.getExtent();
    ext = ext ? ol.extent.extend(ext, e2) : e2.slice();
  }
  if (hasZones) {
    const e3 = zonesSource.getExtent();
    ext = ext ? ol.extent.extend(ext, e3) : e3.slice();
  }

  if (ext && !isNaN(ext[0])) {
    sharedView.fit(ext, { padding:[40,40,40,40], duration:300 });
  }
}

function handleGeoJSON(data) {
  if (!data || data.type !== 'FeatureCollection') {
    alert('Invalid GeoJSON (must be FeatureCollection).');
    return;
  }

  const format = new ol.format.GeoJSON();
  const feats = format.readFeatures(data, {
    dataProjection: PROJ,
    featureProjection: PROJ
  });

  feats.forEach(f => {
    const geom = f.getGeometry();
    if (!geom) return;
    const props = f.getProperties() || {};
    delete props.geometry;

    if (geom.getType() === 'Point') {
      if (props.confidence != null) {
        // predicted
        f.setProperties({ class_name: props.class_name, confidence: props.confidence });
        predPtsSource.addFeature(f);
      } else {
        // user point
        const id = (props.id != null) ? Number(props.id) : nextPointId++;
        f.set('id', id);
        userPtsSource.addFeature(f);
      }
      return;
    }

    if (geom.getType() === 'Polygon') {
      const id = (props.id != null) ? Number(props.id) : nextZoneId++;
      f.set('id', id);
      zonesSource.addFeature(f);
      return;
    }
  });

  updateNextIdsFromSources();
  fitToAllDataIfAny();
}

// D&D wiring (on 2D map viewport)
const viewport2d = map2d.getViewport();
viewport2d.addEventListener('dragover', e => e.preventDefault());
viewport2d.addEventListener('drop', e => {
  e.preventDefault();
  for (const file of e.dataTransfer.files) {
    const reader = new FileReader();
    reader.onload = ev => {
      try { handleGeoJSON(JSON.parse(ev.target.result)); }
      catch (err) { alert('Invalid GeoJSON: ' + err.message); }
    };
    reader.readAsText(file);
  }
});

/* =========================
   Export GeoJSON
   - user points + zones only
========================= */
document.getElementById('btnExport').onclick = () => {
  const format = new ol.format.GeoJSON();

  const userObjs = format.writeFeaturesObject(userPtsSource.getFeatures(), {
    featureProjection: PROJ,
    dataProjection: PROJ
  }).features.map(ft => {
    ft.properties = { id: ft.properties.id };
    return ft;
  });

  const zoneObjs = format.writeFeaturesObject(zonesSource.getFeatures(), {
    featureProjection: PROJ,
    dataProjection: PROJ
  }).features.map(ft => {
    ft.properties = { id: ft.properties.id };
    return ft;
  });

  const fc = { type: 'FeatureCollection', features: [...userObjs, ...zoneObjs] };

  const blob = new Blob([JSON.stringify(fc, null, 2)], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'points_zones.geojson'; a.click();
  URL.revokeObjectURL(url);
};

/* =========================
   Find USER point by ID only
========================= */
const FIND_ZOOM = 17;

function flashFeature(feature) {
  const duration = 1200;
  const start = Date.now();
  const geom = feature.getGeometry().clone();

  const listener = map2d.on('postrender', e => {
    const t = (e.frameState.time - start) / duration;
    if (t > 1) {
      ol.Observable.unByKey(listener);
      return;
    }
    const ctx = e.context;
    const pr = e.frameState.pixelRatio;
    const p = map2d.getPixelFromCoordinate(geom.getCoordinates());

    ctx.save();
    ctx.globalAlpha = 1 - t;
    ctx.lineWidth = 2 * pr;
    ctx.beginPath();
    ctx.arc(p[0]*pr, p[1]*pr, 15*(1+t)*pr, 0, 2*Math.PI);
    ctx.strokeStyle = '#ff0000';
    ctx.stroke();
    ctx.restore();

    map2d.render();
  });
}

document.getElementById('btnFind').onclick = () => {
  const raw = document.getElementById('findId').value.trim();
  const id = Number(raw);
  if (!Number.isFinite(id)) return alert('Enter valid numeric point ID.');

  const f = userPtsSource.getFeatures().find(ft => Number(ft.get('id')) === id);
  if (!f) return alert(`User point ID=${id} not found.`);

  const c = f.getGeometry().getCoordinates();
  sharedView.animate({ center:c, duration:250 }, { zoom:FIND_ZOOM, duration:250 });
  flashFeature(f);
};

// init counters
updateNextIdsFromSources();

/* =========================
   CESIUM / OL-CESIUM SETUP
   - Use map3d as OL backing map
   - Render Cesium in #map3d
   - Load 3D tileset with intensity->greyscale
========================= */
const ol3d = new olcs.OLCesium({ map: map3d });
const scene = ol3d.getCesiumScene();
scene.requestRenderMode = false; // continuous rendering
ol3d.setEnabled(true);



scene.imageryLayers.addImageryProvider(
  new Cesium.WebMapServiceImageryProvider({
    url: "https://geoportal.dgu.hr/services/inspire/orthophoto_lidar_2022_2023/wms",
    layers: "OI.OrthoimageCoverage",
    parameters: {
      service: "WMS",
      request: "GetMap",
      format: "image/jpeg",
      transparent: false,
      version: "1.3.0",
      CRS: "CRS:84"
    }
  })
);




// Load 3D tileset into Cesium scene
async function loadTilesetIntoScene(scene, url) {
  try {
    const tileset = await Cesium.Cesium3DTileset.fromUrl(url);
    scene.primitives.add(tileset);
    await tileset.readyPromise;

    // Intensity â†’ grayscale style
    tileset.style = new Cesium.Cesium3DTileStyle({
      pointSize: 4,
      color: {
        conditions: [
          ['true', 'vec4(${COLOR}.x, ${COLOR}.x, ${COLOR}.x, 1.0)']
        ]
      }
    });

    // Fly to tileset
    scene.camera.flyToBoundingSphere(tileset.boundingSphere, { duration: 2.0 });

    console.log('3D Tileset loaded.');
    return tileset;
  } catch (err) {
    console.error('Failed to load 3D Tileset:', err);
  }
}

// kick off tileset loading
loadTilesetIntoScene(scene, TILESET_URL);
</script>
</body>
</html>
